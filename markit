#!/bin/bash
#	markit	3.1.47	2018-02-07_22:38:16_CST uadmin six-rpi3b.cptx86.com 3.1-4-g336c768 
#	Closes #2 
#	markit	3.1.43	2018-02-07_17:12:56_CST uadmin six-rpi3b.cptx86.com 3.1 
#	Major rewrite to support multiple files 
#	markit	2.02.34	2018-02-05_22:29:50_CST uadmin six-rpi3b.cptx86.com 0.02
#	show current release when entering new release number: this closes issue 1
#	markit	2.01.20	2018-02-05_20:08:39_CST uadmin six-rpi3b.cptx86.com 1.03
#	corrected logic with line description string
#	markit	2.0.14	2018-02-05_19:53:17_CST uadmin six-rpi3b.cptx86.com 4.0
#	add logic for errors and display_help
#	markit	1.2	2017-12-19_14:17:55_CST uadmin rpi3b-two.cptx86.com
#	add FQDN to version line to help understand the system the code was tested on and add git commands
#	markit	1.1	2017-12-18_19:09:50_CST uthree
#	Testing added code to support one line description
#
#	set -x
#	set -v
#
#	I created this script because git fails me when it comes to including the
#	version number and change description in each file being checked-in.
#	Maybe it does, but I don't have anymore time to read and figure that out.  
#	Version control must place a version number in the text when code is checked in!
#	This is not a kernal.  Bite me!
#
#	I am sure some day I will think of a diferent way to create this tool.
#	Git does alot more than I need or want today.
###
display_help() {
echo -e "\nAdd two comment lines of information about file changes & push changes"
echo    "This script uses one arguements;"
echo    "   UNTRACKED_FILES - used to specify the handling of untracked files"
echo    "      no - no untracked files"
echo    "      normal - untracked files and directories"
echo    "      all - Also individual files in untracked directories"
echo    "The first comment line includes file name, version, date, programmer,"
echo    "and hostname as the second line of the file(s).  Followed by a single"
echo    "comment line including a breif description about changes made to the"
echo    "file.  There will be prompts for comment character(s) and description."
#
echo -e "Documentation:https://github.com/BradleyA/markit\n"
echo -e "Example:\t${0}\n"
}
if [ "$1" == "--help" ] || [ "$1" == "-help" ] || [ "$1" == "help" ] || [ "$1" == "-h" ] || [ "$1" == "h" ] || [ "$1" == "-?" ] || [ "$1" == "?" ] ; then
	display_help
	exit 0
fi
###	test for
#	>>>	use cases
#	>>>		blank $1 & no, normal, all
#	>>>		all files are new and not on github
#	>>>		no files need markit and commit with a push
#	>>>		one file need markit
#	>>>		several files need markit
#	>>>		different types of files (x.sh, x.py, etc.) need makrit
#	>>>		?	 objective: mark all file(s): untracked(??), new file that has been added (A), modified(M), staged
#	>>>			I would say yes to all BUT untracked(??) because some time people want untracked files but
#	>>>			they should put them in .gitignore file / right?	
###
UNTRACKED_FILES=${1:-no}
#
CURRENT_RELEASE=`git tag | tail -1`
BEGIN_COMMENT_CHAR=""
END_COMMENT_CHAR=""
FILE_LIST=`git status -s --untracked-files=${UNTRACKED_FILES} | awk '{print $2}'`
NUMBER_COMMITS=`git rev-list HEAD | wc -l`	
TEMP_FILE="TEMP_MARKIT_FILE"
TIME_STAMP=`date +%Y-%m-%d_%H:%M:%S_%Z`
#	The FILE_MESSAGE is a one line breif description about the changes.
FILE_MESSAGE=""
FILE_RELEASE=""
FILE_TEMP="TEMP_MARKIT_FILE"
#	Check if ${FILE_LIST} is zero length
if [ -z "${FILE_LIST}" ] ; then
	echo -e "${0} ${LINENO} [ERROR]:	No file(s) found to mark and push to github.\n"	1>&2
	git status
	display_help
	exit 1
fi
###
# >>>	Need to add a check for agrment, display_help, exit 1; $1 veriable no, notmal, all
###
#	Prompt for release number
echo -e "Files to be marked and pushed to github:\n${FILE_LIST}"
echo    "Current release number: ${CURRENT_RELEASE} "
echo -e "Enter release number to commit files to github (example 3.01).\n\tPress enter to use ${CURRENT_RELEASE} release number."
read     FILE_RELEASE
if [ -z ${FILE_RELEASE} ] ; then
	FILE_RELEASE=${CURRENT_RELEASE}
fi
if [ -z ${FILE_RELEASE} ] ; then
	echo -e "${0} ${LINENO} [ERROR]:	No release number to mark and push to github.\n"       1>&2
	display_help
	exit 1
fi
echo -e "${0} ${LINENO} [INFO]:	Using release number: ${FILE_RELEASE}"	1>&2
#	Prompt for single-line beginning comment character(s)
echo -e "Enter single-line beginning comment character(s) to use\n (example: # // -- ' ! C !* -- // % ;;   /* <!-- <!--- {- /** --[[ %{ (* <# ):"
read BEGIN_COMMENT_CHAR
#	>>>	At a later time I need to add code to support comments that use 
#	>>>	multiple line and/or opening and closing comment character(s) and code requiring to be compiled.
#	>>>	Need a case statement with each comment char matching a file extension; example x.sh, x.py, etc
#	>>>	https://en.wikipedia.org/wiki/Comment_(computer_programming)
#	>>>	echo -e "Enter single-line ending comment character(s) to use\n (example: */ --> ---> -} */ --]] %} *) #> ):"
#	>>>	read END_COMMENT_CHAR
#	>>>	if [ -z ${END_COMMENT_CHAR} ] ; then ERROR message display_help, exit 1
if [ -z ${BEGIN_COMMENT_CHAR} ] ; then
	echo -e "${0} ${LINENO} [ERROR]:        Single-line comment character(s) is required.\n"       1>&2
	display_help
	exit 1
fi
#	Prompt for single line change description
#	>>>	think about how to add git commit -v
#	>>>	git commit -m "$FILE_MESSAGE" $FILE_NAME
echo "Enter a one line description about the changes:"
read FILE_MESSAGE
if [ -z "${FILE_MESSAGE}" ] ; then
	echo -e "${0} ${LINENO} [ERROR]:        Single-line description is required.\n"       1>&2
	display_help
	exit 1
fi
#	Mark each file
for FILE_NAME in ${FILE_LIST} ; do
	touch ${TEMP_FILE}
	head -1 ${FILE_NAME} >> ${TEMP_FILE}
	echo "${BEGIN_COMMENT_CHAR}	${FILE_NAME}	${FILE_RELEASE}.`git rev-list HEAD | wc -l`	${TIME_STAMP} ${USER} `hostname -f` `git describe` ${END_COMMENT_CHAR}" >> ${TEMP_FILE}
	echo "${BEGIN_COMMENT_CHAR}	${FILE_MESSAGE} ${END_COMMENT_CHAR}" >> ${TEMP_FILE}
	tail -n `wc -l ${FILE_NAME} | awk '{print $1  - 1}'` ${FILE_NAME} >> ${TEMP_FILE}
	cp ${TEMP_FILE} ${FILE_NAME}
	rm ${TEMP_FILE}
#	Add file contents to the index
	git add ${FILE_NAME}
done
#	Commit staged file(s) for git push
	git commit -m "${FILE_MESSAGE}"
#	Check if release number is new then add tag reference with new release number
# >>>	   think about changing == to >= (are all release numbers? no A.01 ?)
if ! [ "${FILE_RELEASE}" == "${CURRENT_RELEASE}" ] ; then
	git tag -a ${FILE_RELEASE} -m "${FILE_MESSAGE}"
#	Push changes to github repository
	git push --follow-tags
else
#	Push changes to github repository
	git push
fi
echo -e "${0} ${LINENO} [INFO]:	Done.\n"	1>&2
###
