#!/bin/bash
#	markit	3.1.48	2018-02-07_22:39:36_CST uadmin six-rpi3b.cptx86.com 3.1-5-ge772a21 
#	Closes #2 
#	markit	3.1.43	2018-02-07_17:12:56_CST uadmin six-rpi3b.cptx86.com 3.1 
#	Major rewrite to support multiple files 
#	markit	2.02.34	2018-02-05_22:29:50_CST uadmin six-rpi3b.cptx86.com 0.02
#	show current release when entering new release number: this closes issue 1
#	markit	2.01.20	2018-02-05_20:08:39_CST uadmin six-rpi3b.cptx86.com 1.03
#	corrected logic with line description string
#	markit	2.0.14	2018-02-05_19:53:17_CST uadmin six-rpi3b.cptx86.com 4.0
#	add logic for errors and display_help
#	markit	1.2	2017-12-19_14:17:55_CST uadmin rpi3b-two.cptx86.com
#	add FQDN to version line to help understand the system code was tested on; add git commands
#	markit	1.1	2017-12-18_19:09:50_CST uthree
#	Testing added code to support one line description
#
#	set -x
#	set -v
#
#	I created this script because git fails me when it comes to including the
#	version number and change description in each file being checked-in.
#	Maybe it does, but I don't have anymore time to read and figure that out.  
#	Version control must place a version number in text when code is checked in!
#	This is not a kernal.  Bite me!
###
display_help() {
echo -e "\n${0} - Add two comment lines about file changes & push to github"
echo -e "\nUSAGE:\n      ${0} [no | normal | all]"
echo    "      ${0} [--help | -help | help | -h | h | -? | ?]"
echo -e "\nDESCRIPTION:\nAdd two comment lines of information about file changes to tracked modified"
echo    "files in your Git repository.  Then push those changed files to github."
echo    "To change an untracked file to a tracked file enter, git add <file_name>."
echo    "To prevent an untracked file from being tracked, add file to .gitignore file."
echo    "The first comment line includes file name, version, date, programmer, and"
echo    "hostname as the second line of the file(s).  Followed by a single comment"
echo    "line including a brief description about changes made to the file.  There will"
echo    "be prompts for comment character(s) and description."
echo    "This script uses one arguement;"
echo    "   UNTRACKED_FILES - used to specify the handling of untracked files"
echo    "      no - no untracked files (default)"
echo    "      normal - untracked files and directories"
echo    "      all - Also individual files in untracked directories"
echo -e "\nDOCUMENTATION:\n      https://github.com/BradleyA/markit"
echo -e "\nEXAMPLES:\n      ${0}\n"
echo -e "   Mark untracked files, directories, and files in untracked directories\n\n      ${0} all\n"
}
if [ "$1" == "--help" ] || [ "$1" == "-help" ] || [ "$1" == "help" ] || [ "$1" == "-h" ] || [ "$1" == "h" ] || [ "$1" == "-?" ] || [ "$1" == "?" ] ; then
	display_help
	exit 0
fi
###	test for
#	>>>	use cases
#	>>>		blank $1 & no, normal, all
#	>>>		all files are new and not on github
#	>>>		no files need markit and commit with a push
#	>>>		one file need markit
#	>>>		several files need markit
#	>>>		different types of files (x.sh, x.py, etc.) need makrit
#	>>>		?	 objective: mark all file(s): untracked(??), new file that has been added (A), modified(M), staged
#	>>>			I would say yes to all BUT untracked(??) because some time people want untracked files but
#	>>>			they should put them in .gitignore file / right?	
###
UNTRACKED_FILES=${1:-no}
#
CURRENT_RELEASE=`git tag | tail -1`
BEGIN_COMMENT_CHAR=""
END_COMMENT_CHAR=""
FILE_LIST=`git status -s --untracked-files=${UNTRACKED_FILES} | awk '{print $2}'`
NUMBER_COMMITS=`git rev-list HEAD | wc -l`	
TEMP_FILE="TEMP_MARKIT_FILE"
TIME_STAMP=`date +%Y-%m-%d_%H:%M:%S_%Z`
#	The FILE_MESSAGE is a one line breif description about the changes.
FILE_MESSAGE=""
FILE_RELEASE=""
FILE_TEMP="TEMP_MARKIT_FILE"
#	Check if ${FILE_LIST} is zero length
if [ -z "${FILE_LIST}" ] ; then
	echo -e "${0} ${LINENO} [ERROR]:	No file(s) found to mark and push to github.\n"	1>&2
	git status
	display_help
	exit 1
fi
###
# >>>	Need to add a check for argument, display_help, exit 1; $1 variable no, normal, all
# >>>	add code here
###
#	Prompt for release number
echo -e "Files to be marked and pushed to github:\n${FILE_LIST}"
echo    "Current release number: ${CURRENT_RELEASE} "
echo -e "Enter release number to commit files to github (example 3.01).\n\tPress enter to use ${CURRENT_RELEASE} release number."
read     FILE_RELEASE
if [ -z ${FILE_RELEASE} ] ; then
	FILE_RELEASE=${CURRENT_RELEASE}
fi
if [ -z ${FILE_RELEASE} ] ; then
	echo -e "${0} ${LINENO} [ERROR]:	No release number to mark and push to github.\n"       1>&2
	display_help
	exit 1
fi
echo -e "${0} ${LINENO} [INFO]:	Using release number: ${FILE_RELEASE}"	1>&2
#	Prompt for single-line beginning comment character(s)
echo -e "Enter single-line beginning comment character(s) to use\n (example: # // -- ' ! C !* -- // % ;;   /* <!-- <!--- {- /** --[[ %{ (* <# ):"
read BEGIN_COMMENT_CHAR
#	>>>	At a later time I need to add code to support comments that use 
#	>>>	multiple line and/or opening and closing comment character(s) and code requiring to be compiled.
#	>>>	Need a case statement with each comment char matching a file extension; example x.sh, x.py, etc
#	>>>	https://en.wikipedia.org/wiki/Comment_(computer_programming)
#	>>>	echo -e "Enter single-line ending comment character(s) to use\n (example: */ --> ---> -} */ --]] %} *) #> ):"
#	>>>	read END_COMMENT_CHAR
#	>>>	if [ -z ${END_COMMENT_CHAR} ] ; then ERROR message display_help, exit 1
if [ -z ${BEGIN_COMMENT_CHAR} ] ; then
	echo -e "${0} ${LINENO} [ERROR]:        Single-line comment character(s) is required.\n"       1>&2
	display_help
	exit 1
fi
#	Prompt for single line change description
#	>>>	think about how to add git commit -v
#	>>>	git commit -m "$FILE_MESSAGE" $FILE_NAME
echo "Enter a one line description about the changes:"
read FILE_MESSAGE
if [ -z "${FILE_MESSAGE}" ] ; then
	echo -e "${0} ${LINENO} [ERROR]:        Single-line description is required.\n"       1>&2
	display_help
	exit 1
fi
#	Mark each file
for FILE_NAME in ${FILE_LIST} ; do
	touch ${TEMP_FILE}
	head -1 ${FILE_NAME} >> ${TEMP_FILE}
	echo "${BEGIN_COMMENT_CHAR}	${FILE_NAME}	${FILE_RELEASE}.`git rev-list HEAD | wc -l`	${TIME_STAMP} ${USER} `hostname -f` `git describe` ${END_COMMENT_CHAR}" >> ${TEMP_FILE}
	echo "${BEGIN_COMMENT_CHAR}	${FILE_MESSAGE} ${END_COMMENT_CHAR}" >> ${TEMP_FILE}
	tail -n `wc -l ${FILE_NAME} | awk '{print $1  - 1}'` ${FILE_NAME} >> ${TEMP_FILE}
	cp ${TEMP_FILE} ${FILE_NAME}
	rm ${TEMP_FILE}
#	Add file contents to the index
	git add ${FILE_NAME}
done
#	Commit staged file(s) for git push
	git commit -m "${FILE_MESSAGE}"
#	Check if release number is new then add tag reference with new release number
# >>>	   think about changing == to >= (are all release numbers? no A.01 ?)
if ! [ "${FILE_RELEASE}" == "${CURRENT_RELEASE}" ] ; then
	git tag -a ${FILE_RELEASE} -m "${FILE_MESSAGE}"
#	Push changes to github repository
	git push --follow-tags
else
#	Push changes to github repository
	git push
fi
echo -e "${0} ${LINENO} [INFO]:	Done.\n"	1>&2
###
